# 概述

内存池主要解决的问题是什么？

- **效率问题：**在高并发场景下，频繁地申请和释放内存会带来很大的开销。例如，操作系统每次分配内存时，都需要查找合适的内存空间、更新内存管理数据结构等，这些操作会消耗大量的时间。特别是在多线程环境中，多个线程同时请求内存时，可能会导致线程阻塞，进一步降低系统的响应速度。
  - 内存池预先分配一块较大的内存空间，并将其划分为多个固定大小的内存块。当应用程序需要内存时，直接从内存池中分配一个内存块，无需每次都调用操作系统的内存分配函数，从而大大减少了内存分配的时间开销，提高了内存分配的效率。
- **内存碎片：**频繁的内存分配和释放会导致内存空间被分割成许多小块，这些小块内存可能无法被再次利用，形成内存碎片。内存碎片化会降低内存的利用率，甚至可能导致系统无法分配足够大的内存块，即使系统中仍有足够的未使用内存。
  - 内存池通过预先分配固定大小的内存块，避免了频繁的内存分配和释放操作，从而减少了内存碎片化的产生。内存池中的内存块大小是固定的，这使得内存池可以更高效地管理这些内存块，避免了因不同大小的内存分配和释放而导致的碎片化问题。
- **系统开销：**每次内存分配和释放操作都需要操作系统进行复杂的管理，包括更新内存管理数据结构、处理锁等同步机制等。这些操作会增加系统的开销，尤其是在高并发场景下，频繁的内存操作可能导致系统性能显著下降。
  - 内存池可以作为系统的内存分配器，通过预先分配固定大小的内存块，避免了频繁的内存分配和释放操作，从而减少内存碎片化。内存池还可以根据应用程序的需求，动态调整内存块的大小和数量，进一步优化内存的使用效率。

# 定长内存池

直接向堆申请内存空间：

- Windows：调用VirtualAlloc函数
- Linux：调用brk或mmap函数

成员变量：

- `size_t _SurplusBytes`：对于向堆申请到的大块内存，可以使用一个指针来对其进行管理，但是仅用一个指针是不够的，还需要一个变量来记录这块内存的长度；
- `char* _memory`：进行内存分配的时候，需要对这块内存进行切分，为了方便切分，指向这块内存的指针最好是字符指针，因为指针的类型决定了指针向前或向后走一步有多大的距离，对于字符指针来说，当我们需要分配出去n个字节空间的时候，直接对字符指针进行加n操作即可；
- `void* _freeList`：释放回来的定长内存块也需要被管理，我们可以将这些释放回来的定长内存块链接成一个链表，这里将管理释放回来的内存块链表称作自由链表，所以还需要一个指向自由链表的指针；

> 自由链表是一种数据结构，通常用于管理可用内存块的列表，在动态内存分配中，当需要分配内存时，可以从自由链表中获取一个可用的内存块，当内存不再需要时，将其释放并加入到自由链表，头部节点存储下一个节点的地址；

为什么不用void*类型的指针指向内存块呢？？？

- `void*`类型的指针具有局限性
  - 不能直接进行算术运算：`void*` 指针是一种“无类型”指针，它不能直接进行加法或减法运算。例如，你不能对 `void*` 指针执行 `ptr + n` 操作，因为编译器不知道 `void*` 指针指向的数据类型，也就无法确定每次加法操作应该增加的字节数。
  - 需要显示转换：如果要对 `void*` 指针进行算术运算，必须先将其显式转换为其他类型的指针（如 `char*` 或 `int*` 等）；
- 为什么使用 `char*`类型的指针
  * **字节粒度操作** ：`char*` 指针指向的是 `char` 类型的数据，而 `char` 类型的大小是 1 字节。因此，对 `char*` 指针进行加法或减法运算时，每次操作的单位是字节。例如，`ptr + n` 表示将指针向前移动 `n` 个字节，这正是内存切分操作所需要的。




# 三层缓存

TreadCache（线程本地缓存）

- 线程隔离：通过thread_local关键字实现每个线程独立的缓存实例，避免锁竞争；
- 自由链表管理：通过 `std::array<void*, FREE_LIST_SIZE>`管理不同大小的内存块，通过 `SizeClass`嘞对齐和映射内存请求到对应链表；
- 批量申请：当本地链表为空时，荣国 `fetchFromCentralCache`从CentralCache批量获取内存块；

CentralCache（中心缓存）

- 全局共享：单例模式（饿汉式）管理所有线程共享的内存块，使用自旋锁 `std::atomic_flag`实现桶级锁，减少竞争；
- Span管理：以Span为单位（连续页）从PageCache申请内存，并切分为小块挂载到自由链表；
- 慢开始算法：动态调整批量分配数量，避免一次性分配过多内存；

PageCache

- 系统内存对接：以4KB页为单位向系统申请内存，管理Span并通过 `std::map`按页数组织；
- 合并并分割：释放Span时合并相邻空闲页，分配时按需分割大Span；


## ThreadCache

ThreadCache主要功能是管理线程本地的内存分配和回收：

- allocate：分配内存
- deallocate：回收内存
- 与中心缓存交互：当线程缓存不足的时候，从中心缓存获取内存；当线程缓存的空闲内存过多的时候，将部分内存归还给中心缓存；

```cpp
1.  
// 处理0大小的分配请求
if (size == 0)
{
   size = ALIGNMENT; // 至少分配一个对齐大小
}

为什么size = ALIGNMENT;，这段代码的含义是什么？？？
如果分配器的其他部分（例如内存块的管理逻辑）假设分配的内存块至少有一个对齐大小，那么将 size == 0 的请求转换为分配一个对齐大小的内存块可以保持整个分配器逻辑的一致性。
```
